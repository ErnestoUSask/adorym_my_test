"""Minimal 2-D ptychography reconstruction routines."""

from __future__ import annotations

import random
from dataclasses import dataclass, field
from typing import Iterable, List, Sequence, Tuple

import numpy as np
import torch

from .data import PtychographyData
from .utils import create_circular_probe


@dataclass
class ReconstructionConfig:
    """Parameters controlling the ePIE reconstruction loop."""

    n_epochs: int = 200
    batch_size: int = 64
    object_step: float = 0.25
    probe_step: float = 0.10
    probe_update_start_epoch: int = 0
    detector_shape: Tuple[int, int] | None = None
    random_seed: int | None = 0


@dataclass
class ReconstructionResult:
    """Outputs generated by :class:`SimplePtychoReconstructor`."""

    object_estimate: torch.Tensor
    probe_estimate: torch.Tensor
    history: List[float] = field(default_factory=list)


class SimplePtychoReconstructor:
    """A lightweight implementation of the ePIE ptychography algorithm.

    The class keeps the code path deliberately short so that it is easy to
    experiment with alternative update schemes.  It only depends on NumPy and
    PyTorch, both of which are commonly available in scientific Python
    environments.
    """

    def __init__(
        self,
        object_shape: Tuple[int, int],
        *,
        probe: torch.Tensor | None = None,
        device: torch.device | str = "cpu",
        object_init: torch.Tensor | None = None,
    ) -> None:
        self.device = torch.device(device)
        self.object = self._init_object(object_shape, object_init)
        if probe is None:
            probe = create_circular_probe((64, 64), radius=24, device=self.device)
        self.probe = probe.to(self.device)
        self.history: List[float] = []

    # ------------------------------------------------------------------
    def _init_object(
        self, shape: Tuple[int, int], initial: torch.Tensor | None
    ) -> torch.Tensor:
        if initial is not None:
            return initial.to(torch.complex64).to(self.device)
        mag = torch.ones(shape, dtype=torch.float32, device=self.device)
        phase = torch.zeros(shape, dtype=torch.float32, device=self.device)
        return torch.polar(mag, phase).to(torch.complex64)

    # ------------------------------------------------------------------
    @staticmethod
    def _fft2(field: torch.Tensor) -> torch.Tensor:
        return torch.fft.fft2(field, norm="ortho")

    @staticmethod
    def _ifft2(field: torch.Tensor) -> torch.Tensor:
        return torch.fft.ifft2(field, norm="ortho")

    # ------------------------------------------------------------------
    def _apply_amplitude_constraint(
        self, exit_wave: torch.Tensor, amplitude: torch.Tensor
    ) -> torch.Tensor:
        current_amp = torch.abs(exit_wave)
        phase = torch.where(current_amp > 0, exit_wave / current_amp, torch.zeros_like(exit_wave))
        return amplitude * phase

    # ------------------------------------------------------------------
    def _extract_patch(
        self, array: torch.Tensor, top: int, left: int, shape: Tuple[int, int]
    ) -> torch.Tensor:
        return array[top : top + shape[0], left : left + shape[1]]

    def _insert_patch(
        self, array: torch.Tensor, top: int, left: int, patch: torch.Tensor
    ) -> None:
        array[top : top + patch.shape[0], left : left + patch.shape[1]] = patch

    # ------------------------------------------------------------------
    def _iter_indices(
        self, n_items: int, batch_size: int, *, shuffle: bool
    ) -> Iterable[Sequence[int]]:
        indices = list(range(n_items))
        if shuffle:
            random.shuffle(indices)
        for start in range(0, n_items, batch_size):
            yield indices[start : start + batch_size]

    # ------------------------------------------------------------------
    def reconstruct(
        self,
        data: PtychographyData,
        config: ReconstructionConfig,
        *,
        verbose: bool = True,
        update_probe: bool = True,
    ) -> ReconstructionResult:
        intensities = torch.from_numpy(data.intensities).to(self.device)
        amplitudes = torch.sqrt(torch.clamp(intensities, min=1e-12))
        positions = torch.from_numpy(data.positions).to(self.device)

        n_scan, det_y, det_x = intensities.shape
        patch_shape = self.probe.shape[-2:]

        if config.detector_shape is not None:
            det_y, det_x = config.detector_shape
            amplitudes = amplitudes[..., :det_y, :det_x]

        if config.random_seed is not None:
            random.seed(config.random_seed)

        for epoch in range(config.n_epochs):
            epoch_error = 0.0
            for batch_indices in self._iter_indices(
                n_scan, config.batch_size, shuffle=True
            ):
                for idx in batch_indices:
                    pos_y, pos_x = positions[idx]
                    top = int(round(pos_y.item()))
                    left = int(round(pos_x.item()))

                    if (
                        top < 0
                        or left < 0
                        or top + patch_shape[0] > self.object.shape[0]
                        or left + patch_shape[1] > self.object.shape[1]
                    ):
                        raise ValueError(
                            "Scan position leads to a patch outside the object "
                            f"bounds. Position ({top}, {left}) with patch size "
                            f"{patch_shape} does not fit within object shape "
                            f"{tuple(int(s) for s in self.object.shape)}."
                        )

                    obj_patch = self._extract_patch(self.object, top, left, patch_shape)
                    obj_patch_before = obj_patch.clone()
                    exit_wave = obj_patch * self.probe
                    wave_fft = self._fft2(exit_wave)
                    updated_fft = self._apply_amplitude_constraint(
                        wave_fft, amplitudes[idx]
                    )
                    updated_exit = self._ifft2(updated_fft)

                    diff = updated_exit - exit_wave
                    probe_norm = torch.max(torch.abs(self.probe) ** 2).clamp_min(1e-6)
                    object_update = config.object_step * torch.conj(self.probe) * diff / probe_norm
                    new_patch = obj_patch + object_update
                    self._insert_patch(self.object, top, left, new_patch)

                    if update_probe and epoch >= config.probe_update_start_epoch:
                        obj_norm = torch.max(torch.abs(obj_patch_before) ** 2).clamp_min(1e-6)
                        probe_update = (
                            config.probe_step
                            * torch.conj(obj_patch_before)
                            * diff
                            / obj_norm
                        )
                        self.probe = self.probe + probe_update

                    error = torch.mean((torch.abs(wave_fft) - amplitudes[idx]) ** 2)
                    epoch_error += float(error.detach().cpu())

            epoch_error /= n_scan
            self.history.append(epoch_error)
            if verbose:
                print(f"Epoch {epoch + 1:03d} | mean amplitude error: {epoch_error:.5e}")

        return ReconstructionResult(
            object_estimate=self.object.detach().clone(),
            probe_estimate=self.probe.detach().clone(),
            history=list(self.history),
        )


def run_reconstruction(
    data: PtychographyData,
    *,
    object_shape: Tuple[int, int],
    config: ReconstructionConfig | None = None,
    device: str = "cpu",
    probe: torch.Tensor | None = None,
    object_init: torch.Tensor | None = None,
) -> ReconstructionResult:
    """Convenience wrapper around :class:`SimplePtychoReconstructor`."""

    if config is None:
        config = ReconstructionConfig()
    reconstructor = SimplePtychoReconstructor(
        object_shape, probe=probe, device=device, object_init=object_init
    )
    return reconstructor.reconstruct(data, config)
